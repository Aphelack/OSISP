# Сервер логирования (Log Server)

## Описание
Многопользовательский сервер логирования, который принимает сообщения от нескольких клиентов через именованные каналы (Named Pipes) и записывает их в лог-файл с временными метками и идентификаторами источников.

## Архитектура

### Процесс-сервер (`log_server.exe`)
- Создаёт именованный канал `\\.\pipe\LogServerPipe`
- Принимает подключения от множественных клиентов (до 10 одновременно)
- Для каждого клиента создаёт отдельный поток-обработчик
- Получает сообщения от клиентов
- Записывает их в файл `server.log` с:
  - Временной меткой (миллисекундной точностью)
  - Идентификатором клиента
  - Текстом сообщения
- Использует Critical Section для thread-safe записи в лог-файл
- Отправляет подтверждение (ACK) каждому клиенту

### Процесс-клиент (`log_client.exe`)
- Подключается к именованному каналу сервера
- Отправляет серию сообщений
- Ожидает подтверждения от сервера
- Параметры настраиваются через аргументы командной строки

## Технические детали

### IPC механизм: Named Pipes
- **Тип:** Message-oriented pipes (PIPE_TYPE_MESSAGE)
- **Режим:** Синхронный, блокирующий (PIPE_WAIT)
- **Множественные экземпляры:** PIPE_UNLIMITED_INSTANCES
- **Двунаправленный:** PIPE_ACCESS_DUPLEX

### Структура сообщения
```c
typedef struct {
    DWORD clientId;           // Идентификатор клиента
    TCHAR message[1024];      // Текст сообщения
} LogMessage;
```

### Формат лог-файла
```
[YYYY-MM-DD HH:MM:SS.mmm] [Client-ID] Message text
```

### Синхронизация
- **Critical Section** для защиты доступа к лог-файлу
- Гарантирует атомарность записи от разных потоков
- Предотвращает перемешивание данных

## Сборка и запуск

### Сборка
```bash
make
```

### Автоматическая демонстрация
```bash
./run_demo.sh
```
Запускает сервер и трёх клиентов с разными параметрами:
- Клиент 1: 5 сообщений, задержка 500ms
- Клиент 2: 3 сообщения, задержка 800ms
- Клиент 3: 4 сообщения, задержка 600ms

### Ручной запуск

**Терминал 1 - Сервер:**
```bash
wine log_server.exe
```

**Терминал 2, 3, 4... - Клиенты:**
```bash
wine log_client.exe <client_id> <message_count> <delay_ms>

# Примеры:
wine log_client.exe 1 10 500   # Клиент 1: 10 сообщений, 500ms задержка
wine log_client.exe 2 5 1000   # Клиент 2: 5 сообщений, 1000ms задержка
wine log_client.exe 3 3 200    # Клиент 3: 3 сообщения, 200ms задержка
```

### Остановка
- Сервер: Ctrl+C
- Клиенты: завершаются автоматически после отправки всех сообщений

## Пример работы

### Консоль сервера:
```
=== Log Server Starting ===
Pipe name: \\.\pipe\LogServerPipe
Log file: server.log

Log server is ready. Waiting for clients...
Press Ctrl+C to stop the server.

Waiting for client connection...
Client connected! Creating handler thread...
[Thread 12345] Client handler started
[2025-11-04 19:58:28.159] [Client-1] Message #1 from client 1
[2025-11-04 19:58:28.664] [Client-2] Message #1 from client 2
[2025-11-04 19:58:28.672] [Client-1] Message #2 from client 1
...
```

### Консоль клиента:
```
=== Log Client Started ===
Client ID: 1
Messages to send: 5
Delay between messages: 500 ms

Connecting to log server...
Connected to server!

Sending: Message #1 from client 1
  Server response: ACK
Sending: Message #2 from client 1
  Server response: ACK
...
All messages sent. Disconnecting...
Client finished.
```

### Содержимое server.log:
```
[2025-11-04 19:58:28.159] [Client-1] Message #1 from client 1
[2025-11-04 19:58:28.664] [Client-2] Message #1 from client 2
[2025-11-04 19:58:28.672] [Client-1] Message #2 from client 1
[2025-11-04 19:58:29.164] [Client-3] Message #1 from client 3
[2025-11-04 19:58:29.182] [Client-1] Message #3 from client 1
[2025-11-04 19:58:29.477] [Client-2] Message #2 from client 2
[2025-11-04 19:58:29.688] [Client-1] Message #4 from client 1
[2025-11-04 19:58:29.778] [Client-3] Message #2 from client 3
[2025-11-04 19:58:30.201] [Client-1] Message #5 from client 1
[2025-11-04 19:58:30.290] [Client-2] Message #3 from client 2
[2025-11-04 19:58:30.384] [Client-3] Message #3 from client 3
[2025-11-04 19:58:30.989] [Client-3] Message #4 from client 3
```

## Особенности реализации

### 1. Мультиплексирование
- Сервер обрабатывает множественные подключения одновременно
- Каждый клиент получает отдельный поток-обработчик
- Named Pipe поддерживает множественные экземпляры

### 2. Thread-Safe логирование
- Critical Section защищает запись в файл
- Гарантирует, что сообщения не перемешиваются
- FlushFileBuffers обеспечивает немедленную запись на диск

### 3. Упорядоченность записей
- Временные метки с миллисекундной точностью
- Записи сохраняются в порядке поступления
- Видна последовательность событий от разных клиентов

### 4. Надёжность
- Обработка ошибок подключения
- Graceful shutdown при отключении клиентов
- Автоматическое переподключение клиентов (WaitNamedPipe)

## Анализ корректности

### Отсутствие коллизий ✅
- Critical Section предотвращает race conditions
- Каждая запись атомарна
- Нет перемешивания данных от разных потоков

### Правильный порядок ✅
- Временные метки показывают реальный порядок событий
- Логи точно отражают последовательность сообщений
- Видно чередование сообщений от разных клиентов

### Полнота данных ✅
- Все сообщения записываются
- Ничего не теряется
- Acknowledgments подтверждают доставку

## Эффективность IPC

### Преимущества Named Pipes:
- ✅ Нативный механизм Windows
- ✅ Поддержка message-oriented протокола
- ✅ Автоматическая буферизация
- ✅ Простая модель программирования
- ✅ Работает локально и по сети

### Производительность:
- Низкая латентность (локальные pipes очень быстрые)
- Эффективное использование ресурсов
- Минимальный overhead по сравнению с сокетами
- Подходит для IPC на одной машине

## Возможные улучшения

1. **Архивация логов**
   - Автоматическое создание новых файлов по дате/размеру
   - Ротация старых логов

2. **Фильтрация**
   - Уровни логирования (INFO, WARNING, ERROR)
   - Фильтрация по клиентам

3. **Производительность**
   - Буферизованная запись
   - Асинхронный I/O для файла

4. **Управление**
   - Команды управления серверу
   - Статистика подключений
   - Мониторинг в реальном времени

## Практическая ценность

Эта реализация демонстрирует:
- Правильное использование Named Pipes в Windows
- Многопоточное программирование с синхронизацией
- IPC между процессами
- Централизованное логирование (основа многих production систем)

Аналогичные архитектуры используются в:
- Системах централизованного логирования (syslog, journald)
- Мониторинговых системах
- Серверах приложений
- Распределённых системах
